/*
 * file: AESCipher.java
 * author: Deeksha Sudini
 * course: MSCS630
 * assignment: Lab 5
 * due date: Wednesday, April 18, 2018
 * version: 1.0
 *
 * This file contains the declaration of the
 * AESCipher class.
 */

import java.util.ArrayList;

/*
 * AESCipher
 *
 * This class implements the AES algorithm to produce an Encrypted message
 */
public class AESCipher {
  // Rcon - Rijndael key schedule
  private static final char[] RCON =
    {
      0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
      0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
      0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
      0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
      0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
      0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
      0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
      0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
      0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
      0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
      0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
      0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
      0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
      0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
      0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
      0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d
    };
  // Rijndael S-box
  private static final char[] SBOX =
    {
      0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
      0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
      0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
      0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
      0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
      0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
      0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
      0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
      0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
      0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
      0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
      0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
      0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
      0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
      0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
      0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
    };
  // multiplication by 2
  private static final char[] MUlBY2 =
    {
      0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
      0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
      0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
      0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,
      0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
      0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
      0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
      0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
      0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
      0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
      0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
      0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
      0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
      0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
      0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
      0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5
    };

  // multiplication by 3
  private static final char[] MUlBY3 =
    {
      0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
      0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
      0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
      0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
      0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
      0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
      0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
      0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,
      0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
      0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
      0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,
      0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,
      0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
      0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,
      0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
      0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a
    };

  // This Fixed circulant matrix is for the multiplications in Galois Fields for MixColumns steps
  private static final int[][] RMIXCOLUMNS =
    {
      {2, 3, 1, 1},
      {1, 2, 3, 1},
      {1, 1, 2, 3},
      {3, 1, 1, 2}
    };

  /*
   * Using the Rijndael S-box this function takes an input character and provides a substitution char
   *
   *   'inHex' holds the Char which is to be transformed using the Rijndael S-box
   *   'x' holds the Integer value of the character which is used as an index on Rijndael S-box
   *
   * Return value: Transformed character
   */
  private static char aesSBox(char inHex) {
    int x = (int) inHex;
    return SBOX[x];
  }

  /*
   * aesRcon
   *
   * This function provides a constant from Rcon to a given input integer
   *
   * Parameters:
   *   'round' holds the integer value of the round, used as an index on RCON
   */
  private static char aesRcon(int round) {
    return RCON[round];
  }

  /*
   *
   * This function performs AES specific transformations to the input 128-bit key
   * to generate 10 additional round keys, one on each round.
   *
   * Parameters:
   *   totalKeys holds Original key + 10 rounds keys
   *   val_key it Holds Hexadecimal values as string
   *   key holds the 128-bit key as an array of 16 ASCII values
   *   W[][] holds 4x4 matrix.
   *   result holds all round keys
   *   val_result is a temporary array which hold the key values.
   *   col holds Count for the column index
   *   val Holds the W[col-1]
   *   firstItem holds the first value from the val[]
   *   val_new holds the values from the aesSBox function.
   *   Rcon holds the Round constant for the round
   *   val_String is a temporary string builder to build the key using Array W.
   *
   */
  private static String[] aesRoundKeys(String KeyHex) {

    int totalKeys = 11;

    // Splits the Key String to 16 ASCII Hexadecimal string values (pair of 2)

    String[] val_key = KeyHex.split("(?<=\\G.{2})");
    char[] key = new char[val_key.length];
    for (int i=0; i<val_key.length; i++) {
      key[i] = (char) Integer.parseInt(val_key[i], 16);
    }

    char[][] W = new char[4][44];

    String[] result = new String[totalKeys];
    ArrayList<String> val_result = new ArrayList<>();

    int col = 0;

    // W(0) = key(0), W(1) = key(1), W(2) = key(2), and W(3) = key(3)
    int counter = 0;
    for (int c=0; c<4; c++){
      for (int r=0; r<4; r++) {
        W[r][c] = key[counter];
        counter++;
      }
      col++;
    }

    /* Using the given key in W(0), W(1), W(2), W(3) perform various transformations in the other 40 columns of W
     * to produce the round keys.
     */
    while (col < W[0].length){

      // If the index of the col is a multiple of 4, it indicates its a new round.
      if (col%4 == 0) {

        char[] val = new char[4];
        for (int r=0; r<4; r++) {
          val[r] = W[r][col-1];
        }

        char first = val[0];
        System.arraycopy(val, 1, val, 0, 3);
        val[3] = first;

        char[] val_new = new char[4];
        for (int r=0; r<4; r++) {
          val_new[r] = aesSBox(val[r]);
        }

        char Rcon = aesRcon(col/4);

        val_new[0] = (char) (Rcon ^ val_new[0]);

        for (int r=0; r<4; r++) {
          W[r][col] = (char) (W[r][col-4] ^ val_new[r]);
        }

        col++;

      } else {

        for (int r=0; r<4; r++) {
          W[r][col] = (char) (W[r][col-4] ^ W[r][col-1]);
        }

        col++;

      }

    }

    StringBuilder val_String = new StringBuilder();

    for (int c=0; c<W[0].length; c++) {
      if (c%4 != 0 || c==0) {
        for (int r=0; r<4; r++) {
          val_String.append(String.format("%02X", (int) W[r][c]));
        }
      } else {
        val_result.add(val_String.toString());
        val_String.setLength(0);
        for (int r=0; r<4; r++) {
          val_String.append(String.format("%02X", (int) W[r][c]));
        }
      }
    }

    // To save the last round key
    val_result.add(val_String.toString());
    val_String.setLength(0);

    for (int i=0; i<result.length; i++) {
      result[i] = val_result.get(i);
    }

    return result;
  }

  /*
   *
   * This function performs "Add Round Key" operation, which is XOR of the corresponding input matrix entries,
   * State Matrix and Round Key to generate a new State Matrix.
   *
   * Parameters:
   *   sHex holds input state matrix
   *   keyHex holds input round key
   *   state[][] holds the transformed matrix from the XOR operation of sHex and keyHex
   *   val_StringKey holds Hexadecimal values as string, split from the 128-bit key as a pair of 2 values
   *   val_CharKey holds the 128-bit key as an array of 16 ASCII character values
   *   counter holds integer counter used as an index to traverse through each value in the key[]
   *   key[][] holds the key, ASCII character values in a 4x4 matrix
   *
   * Returns the New State Matrix of size 4x4
   */
  private static char[][] aesStateXOR(char[][] sHex, String keyHex) {

    char[][] state = new char[4][4];

    String[] val_StringKey = keyHex.split("(?<=\\G.{2})");
    char[] val_CharKey = new char[val_StringKey.length];
    for (int i=0; i<val_StringKey.length; i++) {
      val_CharKey[i] = (char) Integer.parseInt(val_StringKey[i], 16);
    }
    int counter=0;
    char[][] key = new char[4][4];
    for (int c=0; c<4; c++) {
      for (int r=0; r<4; r++) {
        key[r][c] = val_CharKey[counter];
        counter++;
      }
    }


    for (int r=0; r<4; r++) {
      for (int c=0; c<4; c++) {
        state[r][c] = (char) (sHex[r][c] ^ key[r][c]);
      }
    }

    return state;
  }

  /*
   * aesNibbleSub
   *
   * This function performs "Substitution" operation, i.e., the entries of the input State Matrix are run through
   * aesSBox function which provides a substitution char using Rijndael S-box
   *
   * Parameters:
   *   inStateHex holds input state matrix
   *   state[][] holds the transformed matrix after the Substitution operation
   *
   * Return value: New State Matrix of size 4x4
   */
  private static char[][] aesNibbleSub(char[][] inStateHex) {

    char[][] state = new char[4][4];

    for (int r=0; r<4; r++) {
      for (int c=0; c<4; c++) {
        state[r][c] = aesSBox(inStateHex[r][c]);
      }
    }

    return state;
  }

  /*
   * aesShiftRow
   *
   * This function performs "Shift Rows" operation, the State Matrix four rows are shifted cyclically to the left by
   * offsets of 0, 1, 2, 3, resulting in a new State Matrix
   *
   * Parameters:
   *   state[][] holds the transformed matrix after the Shift Rows operation
   *   row holds and a single row and is used to perform the shift using arraycopy methods
   *   valHolder holds r number of values for row r starting at head, these values are appended to the end
   *                      of the shifted row variable completing the shift
   *
   * Return value: New State Matrix of size 4x4
   */
  private static char[][] aesShiftRow(char[][] inStateHex) {

    char[][] state = new char[4][4];

    // First row is offset by 0
    for (int r=0; r<1; r++){
      for (int c=0; c<4; c++) {
        state[r][c] = inStateHex[r][c];
      }
    }

    // Shifting rows 2, 3, 4 with offsets 1, 2, 3 respectively
    for (int r=1; r<4; r++) {
      char[] row = new char[4];
      char[] valHolder = new char[r];
      for (int c=0; c<r; c++) {
        valHolder[c] = inStateHex[r][c];
      }
      System.arraycopy(inStateHex[r], r, row, 0, inStateHex[r].length - valHolder.length);
      System.arraycopy(valHolder, 0, row, inStateHex[r].length - valHolder.length, valHolder.length);
      System.arraycopy(row, 0, state[r], 0, row.length);
    }

    return state;
  }

  /*
   * GaloisMult
   *
   * This function works on aesMixColumn by performing Galois Multiplication on the values of State Matrix the Fixed Matrix
   * by the use of lookup tables for byte multiplication by 1, 2, 3
   *
   * Return value: Transformed char value for corresponding value in State Matrix and Fixed Matrix
   */
  private static char GaloisMult(char c, int b) {
    if (b == 2) {
      return MUlBY2[(int)c];
    }
    if (b == 3) {
      return MUlBY3[(int)c];
    }

    return c;
  }

  /*
   * GaloisMult
   *
   * This function performs "Mix Column" operation.
   */
  private static char[][] aesMixColumn(char[][] inStateHex) {

    char[][] state = new char[4][4];

    for (int c=0; c<4; c++) {
      for (int r=0; r<4; r++) {
        state[r][c] = (char)
                (GaloisMult(inStateHex[0][c], RMIXCOLUMNS[r][0]) ^ GaloisMult(inStateHex[1][c], RMIXCOLUMNS[r][1]) ^
                GaloisMult(inStateHex[2][c], RMIXCOLUMNS[r][2]) ^ GaloisMult(inStateHex[3][c], RMIXCOLUMNS[r][3]));
      }
    }

    return state;
  }

  /*
   * AES
   *
   * This function performs AES encryption by performing specific operations on the Input plainText using a 128-bit key
   * and 10 additional round keys generated from the aesRoundKeys method using the original key which results to an
   * encrypted message.
   *
   *   pTextHex holds Input plain text in hexadecimal format
   *   keyHex holds Encryption key in hecadecimal format
   *   answer holds the encrypted messages as its being built
   *   val_pText holds hexadecimal values as string, split from the 128-bit plain text as a pair of 2 values
   *   pText holds the 128-bit key as an array of 16 ASCII character values
   *   stateMatrix[][] holds the plain text in a matrix of 4x4
   *   counter holds integer counter used as an index to traverse through each value in the pText[]
   *   keys holds all the keys, i.e., original key and 10 additional round keys
   *   roundCounter Keeps track of current column
   *   val_stateMatrix holds the transformed State Matrix after each operation
   *
   */
  public static String AES(String pTextHex, String keyHex) {

    StringBuilder answer = new StringBuilder();

    String[] val_pText = pTextHex.split("(?<=\\G.{2})");
    char[] pText = new char[val_pText.length];
    for (int i=0; i<val_pText.length; i++) {
      pText[i] = (char) Integer.parseInt(val_pText[i], 16);
    }

    char[][] stateMatrix = new char[4][4];

    int counter = 0;
    for (int c=0; c<4; c++){
      for (int r=0; r<4; r++) {
        stateMatrix[r][c] = pText[counter];
        counter++;
      }
    }

    String[] keys = aesRoundKeys(keyHex);

    int roundCounter = 0;

    char[][] val_stateMatrix = new char[4][4];
    while (roundCounter < 11) {

      if (roundCounter == 0) {
        val_stateMatrix = aesStateXOR(stateMatrix, keys[roundCounter]);
        roundCounter++;
      }

      if (roundCounter < 10) {
        val_stateMatrix = aesNibbleSub(val_stateMatrix);
        val_stateMatrix = aesShiftRow(val_stateMatrix);
        val_stateMatrix = aesMixColumn(val_stateMatrix);
        val_stateMatrix = aesStateXOR(val_stateMatrix, keys[roundCounter]);
        roundCounter++;
      } else {
        val_stateMatrix = aesNibbleSub(val_stateMatrix);
        val_stateMatrix = aesShiftRow(val_stateMatrix);
        val_stateMatrix = aesStateXOR(val_stateMatrix, keys[roundCounter]);
        roundCounter++;
      }
    }

    for (int c=0; c<4; c++) {
      for (int r=0; r<4; r++) {
        answer.append(String.format("%02X", (int) val_stateMatrix[r][c]));
      }
    }

    return answer.toString();
  }

}
